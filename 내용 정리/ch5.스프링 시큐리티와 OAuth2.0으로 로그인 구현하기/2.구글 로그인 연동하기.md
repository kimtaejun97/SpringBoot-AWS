##User 엔티티와 Repository 생성

***********************

###domain/user/User.java

````java
package com.study.springboot.domain.user;

import com.fasterxml.jackson.databind.ser.Serializers;
import com.study.springboot.domain.BaseTimeEntity;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

import javax.persistence.*;

@Getter
@NoArgsConstructor
@Entity
public class User extends BaseTimeEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String email;

    @Column
    private String picture;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    @Builder
    public User(String name, String email, String picture, Role role){
        this.name =name;
        this.email=email;
        this.picture = picture;
        this.role= role;
    }

    public User update(String name, String picture){
        this.name = name;
        this.picture = picture;
        return this;
    }

    public String getRoleKey(){
        return this.role.getKey();
    }


}
````
:: 엔티티의 필드로는 id, name, email, picture, role을 생성하고,    
name 과 picture 필드는 수정할 수 있게 만들어준다.
게스트인지, 유저인지 확인 할 수 있더록 Role의 key를 가져올 수 있는 메소드 작성.    
:: @Enumerated(Enumtype.STRING) : 기본적으로 int 형태로 enum값을 저장하게 되는데,    
무엇을 의미하는지 알기 어렵기 때문에 String형태로 변경.

###domain/user/Role enum class
````java
package com.study.springboot.domain.user;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum Role {
    GUEST("ROLE_GUEST","손님"),
    USER("ROLE_USER","일반 사용자");

    private final String key;
    private final String title;
}
````
:: 스프링 시큐리티에서의 권한 코드는 항상 ROLE_XXX의 형태이다.
때문에 키값을 ROLE_XXX형태로 작성함.


###domain/user/UserRepository interface
````java
package com.study.springboot.domain.user;

import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User,Long> {
    //email로 이미 가입된 이메일인지 확인.
    Optional<User> findByEmail(String email);
}

````
:: findByEmail : 소셜 로그인으로 반환되는 값인 email을 통해 이미 생성된 사용자인지를    
판별하기 위한 메소드.


##OAuth 라이브러리를 이용한 소셜 로그인
**********

###build.gradle 의존성 추가
````
    compile('org.springframework.boot:spring-boot-starter-oauth2-client')
````
:: 소셜 로그인 등 클라이언트 입장에서 소셜 기능 구현시 필요한 의존성으로  
스프링 시큐리티 oauth2 client와 jose를 기본으로 관리해 준다.


### config/auth/SecurityConfig.java
````java
package com.study.springboot.config.auth;

import com.study.springboot.domain.user.Role;
import lombok.RequiredArgsConstructor;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@RequiredArgsConstructor
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    private final CustomOAuth2UserService customOAuth2UserService;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .csrf().disable()
                .headers().frameOptions().disable()
            .and()
                .authorizeRequests()
                .antMatchers("/","./css/**","/images/**",
                        "/js/**","/h2-console/**").permitAll()
                .antMatchers("/api/v1/**").hasRole(Role.USER.name())
                .anyRequest().authenticated()
            .and()
                .logout()
                    .logoutSuccessUrl("/")
            .and()
                .oauth2Login()
                    .userInfoEndpoint()
                        .userService(customOAuth2UserService);

    }
}

````

:: Spring Security에서는 H2 데이터 베이스 콘솔의 접근을 차단 한다.    
때문에 csrf를 중지하고 x-frame-options을 중지한 후 h2-console url 요청을 허용해 주어야 한다.    

:: authorizeRequests : URL별 권한을 관리설정 하는 옵션의 시작점.    
authorizeRequests가 선언되어야 antMatchers 옵션을 사용할 수 있다.

:: antMatchers : 권한 관리 대상을 지정. permitAll을 이용하여 모두에게 권한을 주거나,    
Role.USER.name()과 같이 제한된 접근을 허용할 수 있다.

::anuRequest : antMatchers에서 지정된 url 이외의 나머지 url을 나타난다.    
.authenticated ->인증된 사용자에게만 허용